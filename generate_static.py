"""
The Artist (Job B) -# SOVEREIGN SENTINEL | generate_static.py v32.60
# Static Site Generator for Sovereign Sentinel Dashboard
STRICT RULE: NO NETWORK CALLS.
Reads live_state.json and generates index.html.
"""

import json
import os
import sys
import math
from datetime import datetime
import re
from jinja2 import Template
from utils import truncate_decimal, format_gbp_truncate, format_pct_truncate

# ==============================================================================
# CONFIGURATION
# ==============================================================================
STATE_FILE = "live_state.json"
TEMPLATE_FILE = "templates/base.html"
OUTPUT_FILE = "index.html"

def load_state():
    """Reads the Live State snapshot generated by Job A."""
    if not os.path.exists(STATE_FILE):
        print(f"[ARTIST] [ERROR] State file {STATE_FILE} not found. please run the Auditor (Job A) first.")
        return None
        
    try:
        with open(STATE_FILE, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"[ARTIST] [ERROR] Could not read state file: {e}")
        return None

def safe_val(val, default=0.0):
    if val is None: return default
    try:
        f = float(val)
        if math.isnan(f): return default
        return f
    except:
        return default

def format_gbp(val):
    """Legacy function - use format_gbp_truncate for new code."""
    return format_gbp_truncate(val)

# v32.5: Oracle Ring Engine
# v32.13: Sovereign Finality - Artist Ring
def generate_oracle_ring(holdings, total_invested):
    if not holdings: return ""
    
    # Sort: Largest first
    sorted_holdings = sorted(holdings, key=lambda x: x.get('Value_GBP', 0), reverse=True)
    
    # v32.61: Sovereign Finality - Leader Lines & Expanded Donut
    radius = 90
    center_x = 150
    center_y = 150
    circum = 2 * math.pi * radius
    cumulative_offset = 0
    svg_elements = []
    
    # Vibrant Palette
    colors = ["#4f46e5", "#10b981", "#ef4444", "#f59e0b", "#8b5cf6", "#ec4899", "#06b6d4", "#3b82f6", "#f43f5e", "#10b981"]

    for i, h in enumerate(sorted_holdings):
        val = h.get('Value_GBP', 0)
        weight = (val / total_invested * 100) if total_invested > 0 else 0
        
        if weight < 0.5: continue # Tighter clean up for visual clarity
        
        color = colors[i % len(colors)]
        dash_len = (weight / 100) * circum
        
        # --- LEADER LINE GEOMETRY ---
        # 1. Midpoint of the slice (in terms of circumference progress)
        # Note: We rotate -90deg, so 0 is at 12 o'clock. 
        # offset is negative in SVG, so we track cumulative positive for math
        current_wedge_center = cumulative_offset + (dash_len / 2)
        
        # Convert to angle in radians (0 at 3 o'clock for math, so subtract 90deg/PI/2)
        angle_ratio = current_wedge_center / circum 
        angle_rad = (angle_ratio * 2 * math.pi) - (math.pi / 2)
        
        # 2. Slice Edge Point (Start of leader)
        sx = center_x + radius * math.cos(angle_rad)
        sy = center_y + radius * math.sin(angle_rad)
        
        # 3. Label Elbow Point (Further out)
        label_r = 135  # Push out to clean space
        lx = center_x + label_r * math.cos(angle_rad)
        ly = center_y + label_r * math.sin(angle_rad)
        
        # 4. Label Anchor Point (Horizontal line)
        # If left side, go left. If right side, go right.
        is_right = lx >= center_x
        ax = lx + (15 if is_right else -15)
        ay = ly
        
        # Text Anchor
        text_anchor = "start" if is_right else "end"
        text_x = ax + (5 if is_right else -5)
        
        # Data
        ticker = h.get('Ticker', 'Asset')
        safe_name = h.get('Name', ticker).replace("'", "\\'")
        pct_fmt = f"{weight:.1f}%"
        
        # SVG Construction
        # A. The Slice
        svg_elements.append(f"""
            <circle r="{radius}" cx="{center_x}" cy="{center_y}" fill="transparent"
                stroke="{color}" stroke-width="20"
                stroke-dasharray="{dash_len} {circum}"
                stroke-dashoffset="-{cumulative_offset}" 
                transform="rotate(-90 {center_x} {center_y})"
                class="donut-segment segment-{ticker}"
                onmouseover="showTT('{safe_name}', '{pct_fmt}', '{color}')"
                onmouseout="hideTT()"
                onclick="highlightSegment('{ticker}')"
                style="cursor: pointer; transition: all 0.3s;"></circle>
        """)
        
        # B. The Leader Line (Thin 1px)
        svg_elements.append(f"""
            <path d="M{sx},{sy} L{lx},{ly} L{ax},{ay}" 
                  fill="none" stroke="{color}" stroke-width="1" opacity="0.8" />
            <circle cx="{sx}" cy="{sy}" r="1.5" fill="{color}" />
        """)
        
        # C. The Label
        svg_elements.append(f"""
            <text x="{text_x}" y="{ay}" dy="0.3em" text-anchor="{text_anchor}" 
                  class="text-[0.55rem] font-bold fill-gray-500 mono" 
                  style="pointer-events: none;">{ticker} {pct_fmt}</text>
        """)
        
        cumulative_offset += dash_len

    return f"""
    <svg viewBox="0 0 300 300" class="w-full h-full overflow-visible">
        <!-- Inner Track -->
        <circle cx="{center_x}" cy="{center_y}" r="{radius}" stroke="#f3f4f6" stroke-width="16" fill="none" opacity="0.5" />
        {''.join(svg_elements)}
    </svg>
    """

def render():
    print(f"Starting The Artist (Job B) [v0.15.11 Sovereign Finality]... ({datetime.now().strftime('%H:%M:%S')})")
    
    # 1. Load Data
    state = load_state()
    if not state:
        sys.exit(1)
        
    meta = state.get('meta', {})
    holdings = state.get('holdings', [])
    sniper_raw = state.get('sniper', [])
    account = state.get('account', {})
    orb_intel = state.get('orb_intel', {})
    
    # v32.14: HOT RELOAD of Intelligence (Fixes Stale Data)
    orb_path = os.path.join(os.path.dirname(__file__), "data", "orb_intel.json")
    if os.path.exists(orb_path):
        try:
            with open(orb_path, 'r') as f:
                orb_intel = json.load(f)
                print(f"      [DATA] Hot-loaded orb_intel.json (Fresh Intelligence)")
        except:
            print("      [WARN] Failed to hot-load orb_intel.json, using state snapshot.")

    # v0.15.13: Fix Markdown Bolding in Briefing
    if 'briefing' in orb_intel:
        # Replace **bold** with <b>bold</b>
        orb_intel['briefing'] = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', orb_intel['briefing'])
        # Replace newlines with <br> for HTML rendering
        orb_intel['briefing'] = orb_intel['briefing'].replace('\n', '<br>')
    
    print(f"      [DATA] Snapshot Timestamp: {meta.get('timestamp', 'N/A')}")
    print(f"      [DATA] Processing {len(holdings)} holdings.")

    # 2. Extract Metrics
    total_wealth = safe_val(account.get('totalValue', account.get('total', 0.0)))
    
    cash_data = account.get('cash', {})
    if isinstance(cash_data, dict):
        cash_dry = safe_val(cash_data.get('availableToTrade'))
        blocked = safe_val(cash_data.get('reservedForOrders'))
    else:
        cash_dry = safe_val(account.get('free'))
        blocked = safe_val(account.get('blocked'))
        
    invest_data = account.get('investments', {})
    if isinstance(invest_data, dict):
        # v0.10: COMPREHENSIVE TOTAL RETURN (matches T212 Mobile App methodology)
        # ======================================================================
        # Realized P/L from API: £{realized_pl:,.2f} (Trade gains/losses)
        # Unrealized P/L from API: £{unrealized_pl:,.2f} (Paper gains/losses)
        # Dividends from Ledger: £{total_dividends:,.2f}
        # Interest from Ledger: £{total_interest:,.2f}
        # Fees/Taxes from Ledger: £{total_fees:,.2f}
        
        realized_pl = safe_val(invest_data.get('realizedProfitLoss'))
        unrealized_pl = safe_val(invest_data.get('unrealizedProfitLoss'))
        
        # Load supplemental data from Ledger Cache
        total_dividends = 0.0
        total_interest = 0.0
        total_fees = 0.0
        other_income = 0.0
        
        try:
            cache_path = os.path.join(os.path.dirname(__file__), "data", "ledger_cache.json")
            if os.path.exists(cache_path):
                with open(cache_path, 'r') as f:
                    ledger = json.load(f)
                    assets = ledger.get('assets', {})
                    total_dividends = sum(a.get('dividends', 0) for a in assets.values())
                    
                    globs = ledger.get('global', {})
                    total_interest = globs.get('interest', 0.0)
                    total_fees = globs.get('fees_taxes', 0.0) # This is usually negative in our cache
                    other_income = globs.get('other_income', 0.0)
        except:
            pass

        # Formula matches Trading 212 app:
        # P/L + Dividends + Interest + Other - Fees/Taxes
        total_return = realized_pl + unrealized_pl + total_dividends + total_interest + total_fees + other_income
        total_cost = safe_val(invest_data.get('totalCost'))
    else:
        total_return = safe_val(account.get('ppl'))
        total_cost = safe_val(account.get('invested'))
    
    # v31.2: Calculate rate of return with truncation
    return_rate_pct = 0.0
    if total_cost > 0:
        return_rate_pct = truncate_decimal((total_return / total_cost) * 100, 2)

    # 3. Heatmap Data
    heatmap_series = []
    for h in holdings:
        val = safe_val(h.get('Value_GBP', h.get('Value', 0)))
        pnl = safe_val(h.get('PL_GBP', h.get('PL', 0)))
        
        invested_val = val - pnl
        pct = (pnl / invested_val) if invested_val > 0 else 0.0
        
        # v32.7: Sovereign Guard Keys
        # v32.61: Sovereign Heatmap Data Structure
        # 1. Ticker (Top Left)
        # 2. £ P/L (Middle)
        # 3. % Change (Bottom)
        heatmap_series.append({
            'x': h.get('Ticker', 'N/A'),
            'y': truncate_decimal(val, 2),
            # STRICT LABEL DATA for JS Renderer
            'label_ticker': h.get('Ticker', 'N/A'),
            'label_pl': f"{'+' if pnl >= 0 else ''}£{abs(pnl):,.2f}",
            'label_pct': f"{pct*100:+.2f}%",
            # Color logic helper
            'is_profit': pnl >= 0,
            # Legacy fields for safety
            'formatted_value': f"£{val:,.2f}"
            # Removed redundant fields to prevent leakage
        })

    # 4. Fortress Table
    fortress_display = []
    for h in holdings:
        val = safe_val(h.get('Value_GBP', h.get('Value', 0))) # Support both keys
        pnl = safe_val(h.get('PL_GBP', h.get('PL', 0)))
        invested = val - pnl
        pct = (pnl / invested) * 100 if invested > 0 else 0.0
        
        tier = h.get('Tier', h.get('tier', '2'))
        target_weight = 0.08 if tier in ['1+', '1'] else 0.05
        current_weight = (val / total_wealth) if total_wealth > 0 else 0.0
        
        fortress_display.append({
            # New keys for my new section
            'ticker': h.get('Ticker', 'N/A'),
            'company': h.get('Name', h.get('Ticker', 'N/A')),
            'shares': truncate_decimal(safe_val(h.get('Shares')), 4),
            'avg_price': truncate_decimal(safe_val(h.get('Avg_Price')), 2),
            'current_price': truncate_decimal(safe_val(h.get('Price')), 2),
            'value_gbp': truncate_decimal(val, 2),
            'real_pl_gbp': truncate_decimal(pnl, 2),
            'real_pl_pct': truncate_decimal(pct, 2),
            'tier': tier,
            # Legacy keys for existing Fortress loop (line 694)
            'book_cost': truncate_decimal(val - pnl, 2),
            'weight_current': truncate_decimal(safe_val(h.get('Weight')) / 100.0, 4) if 'Weight' in h else truncate_decimal(current_weight, 4),
            'weight_target': truncate_decimal(target_weight, 4),
            'real_pl': truncate_decimal(pnl, 2),
            'fx_impact': truncate_decimal(safe_val(h.get('FX_Impact')), 2),
            'qell_rating': 'PASS', # Default or calc if needed
            'qell_score': 5,        # Default or calc if needed
            'action': 'HOLD'       # Default
        })
    
    # Sort by Real P/L (Best to Worst)
    fortress_display.sort(key=lambda x: x['real_pl_gbp'], reverse=True)

    # 5. Sniper List
    sniper_display = []
    for s in sniper_raw:
        dist = safe_val(s.get('distance_pct'))
        snippet = s.get('hypothesis', s.get('default_thesis', 'No intelligence available.'))
        src = s.get('source', 'System Default')
        
        # Calculate target params for template compatibility
        tier = s.get('tier', '2')
        t_weight = 0.08 if tier in ['1+', '1'] else 0.05
        t_gbp = total_wealth * t_weight
        l_price = safe_val(s.get('target_price'))
        
        sniper_display.append({
            'ticker': s.get('t212_ticker', s.get('ticker', 'N/A')),
            'name': s.get('name', 'N/A'),
            'tier': tier,
            'hypothesis': snippet,
            'source': src,
            'limit_price': l_price,
            'target_weight': t_weight,
            'target_gbp': t_gbp,
            'expected_growth': safe_val(s.get('expected_growth')),
            'shares': int(t_gbp / l_price) if l_price > 0 else 0,
            # Additional keys
            'current_price': truncate_decimal(safe_val(s.get('live_price')), 2),
            'distance_pct': truncate_decimal(dist, 2),
            'status': s.get('status', 'WATCH')
        })

    # 6. Final Template Context
    now = datetime.now()
    tax_end = datetime(now.year + (1 if now.month > 4 or (now.month == 4 and now.day > 5) else 0), 4, 5)
    days_to_tax = (tax_end - now).days

    # v31.6 Account History Loading
    history_log = []
    log_path = "data/history_log.json"
    if os.path.exists(log_path):
        try:
            with open(log_path, 'r') as f:
                history_log = json.load(f)
                history_log.sort(key=lambda x: x[0])
        except Exception as e:
            print(f"      [WARN] History log load failed: {e}")

    # v32.14 Sovereign Guard logic: Legend & Invested Funds Weight
    total_invested = total_wealth - cash_dry - blocked
    if total_invested <= 0:
        total_invested = sum(h.get('Value_GBP', 0) for h in holdings)
        
    # v32.13: Generate Oracle Ring with the correct denominator
    donut_chart_svg = generate_oracle_ring(holdings, total_invested)

    # v32.13: Compact Grid Legend (Tickers Only)
    # Using 'ticker-legend' class for updated CSS
    legend_html = '<div class="ticker-legend">'
    sorted_holdings = sorted(holdings, key=lambda x: x.get('Value_GBP', 0), reverse=True)
    
    colors = ["#4f46e5", "#10b981", "#ef4444", "#f59e0b", "#8b5cf6", "#ec4899", "#06b6d4", "#3b82f6", "#f43f5e", "#10b981"]
    
    for i, h in enumerate(sorted_holdings):
        val = h.get('Value_GBP', 0)
        weight = (val / total_invested * 100) if total_invested > 0 else 0
        
        # Show even small holdings in legend if they exist, but maybe limit count if massive
        if weight < 0.01: continue 
        
        ticker = h.get('Ticker', 'N/A')
        color = colors[i % len(colors)]
        safe_name = h.get('Name', ticker).replace("'", "\\'")
        pct_fmt = f"{weight:.1f}%"
        
        legend_html += f"""
        <div class="legend-ticker hover:bg-gray-50 transition-colors" 
             onclick="highlightSegment('{ticker}')"
             onmouseover="showTT('{safe_name}', '{pct_fmt}', '{color}')"
             onmouseout="hideTT()"
             style="border-left: 3px solid {color};">
            {ticker}
        </div>
        """
    legend_html += "</div>"

    context = {
        'version': 'v32.61',
        'last_update': datetime.now().strftime('%H:%M %d/%m'),
        "meta": {"timestamp": datetime.now().strftime("%Y-%m-%d %H:%M"), "version": "v32.61 Sovereign Finality"},
        'sync_time': datetime.now().strftime('%d/%m %H:%M'),
        'total_wealth_str': format_gbp_truncate(total_wealth),
        'total_return_str': f"{'+' if total_return >= 0 else ''}{format_gbp_truncate(total_return)}",
        'return_pct_str': f"{return_rate_pct:+.2f}%",
        'cash_dry_str': format_gbp_truncate(cash_dry),
        'available_dry_str': format_gbp_truncate(cash_dry),
        'pending_cash_str': format_gbp_truncate(blocked),
        'env': meta.get('env', 'LIVE'),
        'allocation_donut': donut_chart_svg,
        'legend_html': legend_html, # v32.13 Compact Legend
        'holdings': holdings,
        'fortress_holdings': fortress_display,
        'sniper_architect': sniper_display,
        'heatmap_dataset': json.dumps(heatmap_series),
        'account_history': json.dumps(history_log),
        'pending_orders': [],
        'portfolio_metrics': {
            'cash_balance': cash_dry,
            'total_wealth': total_wealth,
            'cash_hurdle': 0.038,
            'total_cost': total_cost,
            'unrealized_pl': unrealized_pl,
            'unrealized_pl_pct': (unrealized_pl / total_cost * 100) if total_cost > 0 else 0.0
        },
        'orb_intel': orb_intel,
        'solar': {
            'phase': 'STABLE',
            'tax': {
                'Limit Sentinel': 'Locked',
                'Days to April 5': str(days_to_tax),
                'Loss Harvesting': 'N/A (Tax Free)',
                'Bed & Breakfast': 'Clear'
            }
        }
    }

    # 7. Rendering Logic
    if not os.path.exists(TEMPLATE_FILE):
        print(f"[ARTIST] [ERROR] Template missing: {TEMPLATE_FILE}")
        return

    try:
        with open(TEMPLATE_FILE, 'r', encoding='utf-8') as f:
            template_code = f.read()
            
        template = Template(template_code)
        output_html = template.render(context)
        
        with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
            f.write(output_html)
            
        print(f"      [SUCCESS] Dashboard written to {OUTPUT_FILE} ({len(output_html)} bytes)")
        
    except Exception as e:
        print(f"      [ERROR] Rendering Failed: {e}")

if __name__ == "__main__":
    render()
