"""
The Artist (Job B) - v0.01 Sovereign Finality
The Renderer for Sovereign Sentinel.
STRICT RULE: NO NETWORK CALLS.
Reads live_state.json and generates index.html.
"""

import json
import os
import sys
import math
from datetime import datetime
from jinja2 import Template
from utils import truncate_decimal, format_gbp_truncate, format_pct_truncate

# ==============================================================================
# CONFIGURATION
# ==============================================================================
STATE_FILE = "live_state.json"
TEMPLATE_FILE = "templates/base.html"
OUTPUT_FILE = "index.html"

def load_state():
    """Reads the Live State snapshot generated by Job A."""
    if not os.path.exists(STATE_FILE):
        print(f"[ARTIST] [ERROR] State file {STATE_FILE} not found. please run the Auditor (Job A) first.")
        return None
        
    try:
        with open(STATE_FILE, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"[ARTIST] [ERROR] Could not read state file: {e}")
        return None

def safe_val(val, default=0.0):
    if val is None: return default
    try:
        f = float(val)
        if math.isnan(f): return default
        return f
    except:
        return default

def format_gbp(val):
    """Legacy function - use format_gbp_truncate for new code."""
    return format_gbp_truncate(val)

# v32.5: Oracle Ring Engine
# v32.13: Sovereign Finality - Artist Ring
def generate_oracle_ring(holdings, total_invested):
    if not holdings: return ""
    
    # Sort: Largest first
    sorted_holdings = sorted(holdings, key=lambda x: x.get('Value_GBP', 0), reverse=True)
    
    # v32.14: Sovereign Finality - Leader Lines
    # Parameters for layout
    radius = 65
    label_r = 90 # Radius for label placement
    circum = 2 * math.pi * radius
    cumulative_offset = 0
    svg_elements = []
    
    # Vibrant Palette
    colors = ["#4f46e5", "#10b981", "#ef4444", "#f59e0b", "#8b5cf6", "#ec4899", "#06b6d4", "#3b82f6", "#f43f5e", "#10b981"]

    for i, h in enumerate(sorted_holdings):
        val = h.get('Value_GBP', 0)
        weight = (val / total_invested * 100) if total_invested > 0 else 0
        
        if weight < 1.0: continue # Filter strictly for chart cleanliness
        
        color = colors[i % len(colors)]
        dash_len = (weight / 100) * circum
        
        # Angles for Slice Placement
        # Note: SVG circle stroke starts at 3 o'clock (0 rad). We rotate -90 to start at 12 o'clock.
        # accumulated length determines the start of this segment.
        
        # Angle of the generic start of this segment (in 0-1 percentage of circle)
        segment_start_pct = (cumulative_offset / circum)
        segment_len_pct = (dash_len / circum)
        
        # Midpoint of the segment in degrees (0 = top/12oclock due to rotate(-90))
        # But 'cumulative_offset' is a stroke-dashoffset which goes COUNTER-clockwise or clockwise depending on impl.
        # Standard logic: offset pushes the start back? 
        # Easier Math: Just track cumulative degrees.
        # Let's use pure angles for the Leader Lines math, unrelated to the stroke-dash trickery, 
        # ensuring we map 1:1.
        # Stroke Dash logic: dasharray="len gap", offset="-Start".
        # This draws the segment starting at 'Start' around the circle.
        
        mid_angle_turn = segment_start_pct + (segment_len_pct / 2)
        # Convert turn (0-1) to Radians, adjusted for -90deg rotation.
        # 0 turn = Top (12). 0.25 = Right (3). 
        mid_angle_rad = (mid_angle_turn * 2 * math.pi) - (math.pi / 2)
        
        # Points
        # Surface Point (on ring)
        sx = 100 + radius * math.cos(mid_angle_rad)
        sy = 100 + radius * math.sin(mid_angle_rad)
        
        # Elbow Point (slightly out)
        ex = 100 + label_r * math.cos(mid_angle_rad)
        ey = 100 + label_r * math.sin(mid_angle_rad)
        
        # Label alignment
        is_right = math.cos(mid_angle_rad) >= 0
        text_anchor = "start" if is_right else "end"
        label_x = ex + (5 if is_right else -5)
        
        ticker = h.get('Ticker', 'Asset')
        safe_name = h.get('Name', ticker).replace("'", "\\'")
        pct_fmt = f"{weight:.1f}%"
        
        # SVG Construction
        svg_elements.append(f"""
            <!-- Slice -->
            <circle r="{radius}" cx="100" cy="100" fill="transparent"
                stroke="{color}" stroke-width="20"
                stroke-dasharray="{dash_len} {circum}"
                stroke-dashoffset="-{cumulative_offset}" 
                transform="rotate(-90 100 100)"
                class="donut-segment segment-{ticker}"
                data-ticker="{ticker}"
                onmouseover="showTT('{safe_name}', '{pct_fmt}', '{color}')"
                onmouseout="hideTT()"
                onclick="highlightSegment('{ticker}')"
                style="cursor: pointer; transition: all 0.3s;"></circle>
            
            <!-- Leader Line -->
            <line x1="{sx}" y1="{sy}" x2="{ex}" y2="{ey}" stroke="{color}" stroke-width="1" opacity="0.6" />
                
            <!-- Label (Ticker + %) -->
            <text x="{label_x}" y="{ey}" dy="0.3em" text-anchor="{text_anchor}" 
                class="text-[0.4rem] font-bold fill-gray-500 mono" style="pointer-events: none;">{ticker} {pct_fmt}</text>
        """)
        
        cumulative_offset += dash_len

    return f"""
    <svg viewBox="0 0 200 200" class="w-full h-full overflow-visible">
        <circle cx="100" cy="100" r="{radius}" stroke="#f3f4f6" stroke-width="18" fill="none" />
        {''.join(svg_elements)}
        <!-- NO CENTER TEXT As Requested -->
    </svg>
    """

def render():
    print(f"Starting The Artist (Job B) [v0.15 Sovereign Finality]... ({datetime.now().strftime('%H:%M:%S')})")
    
    # 1. Load Data
    state = load_state()
    if not state:
        sys.exit(1)
        
    meta = state.get('meta', {})
    holdings = state.get('holdings', [])
    sniper_raw = state.get('sniper', [])
    account = state.get('account', {})
    orb_intel = state.get('orb_intel', {})
    
    print(f"      [DATA] Snapshot Timestamp: {meta.get('timestamp', 'N/A')}")
    print(f"      [DATA] Processing {len(holdings)} holdings.")

    # 2. Extract Metrics
    total_wealth = safe_val(account.get('totalValue', account.get('total', 0.0)))
    
    cash_data = account.get('cash', {})
    if isinstance(cash_data, dict):
        cash_dry = safe_val(cash_data.get('availableToTrade'))
        blocked = safe_val(cash_data.get('reservedForOrders'))
    else:
        cash_dry = safe_val(account.get('free'))
        blocked = safe_val(account.get('blocked'))
        
    invest_data = account.get('investments', {})
    if isinstance(invest_data, dict):
        # v0.10: COMPREHENSIVE TOTAL RETURN (matches T212 Mobile App methodology)
        # ======================================================================
        # Realized P/L from API: £{realized_pl:,.2f} (Trade gains/losses)
        # Unrealized P/L from API: £{unrealized_pl:,.2f} (Paper gains/losses)
        # Dividends from Ledger: £{total_dividends:,.2f}
        # Interest from Ledger: £{total_interest:,.2f}
        # Fees/Taxes from Ledger: £{total_fees:,.2f}
        
        realized_pl = safe_val(invest_data.get('realizedProfitLoss'))
        unrealized_pl = safe_val(invest_data.get('unrealizedProfitLoss'))
        
        # Load supplemental data from Ledger Cache
        total_dividends = 0.0
        total_interest = 0.0
        total_fees = 0.0
        other_income = 0.0
        
        try:
            cache_path = os.path.join(os.path.dirname(__file__), "data", "ledger_cache.json")
            if os.path.exists(cache_path):
                with open(cache_path, 'r') as f:
                    ledger = json.load(f)
                    assets = ledger.get('assets', {})
                    total_dividends = sum(a.get('dividends', 0) for a in assets.values())
                    
                    globs = ledger.get('global', {})
                    total_interest = globs.get('interest', 0.0)
                    total_fees = globs.get('fees_taxes', 0.0) # This is usually negative in our cache
                    other_income = globs.get('other_income', 0.0)
        except:
            pass

        # Formula matches Trading 212 app:
        # P/L + Dividends + Interest + Other - Fees/Taxes
        total_return = realized_pl + unrealized_pl + total_dividends + total_interest + total_fees + other_income
        total_cost = safe_val(invest_data.get('totalCost'))
    else:
        total_return = safe_val(account.get('ppl'))
        total_cost = safe_val(account.get('invested'))
    
    # v31.2: Calculate rate of return with truncation
    return_rate_pct = 0.0
    if total_cost > 0:
        return_rate_pct = truncate_decimal((total_return / total_cost) * 100, 2)

    # 3. Heatmap Data
    heatmap_series = []
    for h in holdings:
        val = safe_val(h.get('Value_GBP', h.get('Value', 0)))
        pnl = safe_val(h.get('PL_GBP', h.get('PL', 0)))
        
        invested_val = val - pnl
        pct = (pnl / invested_val) if invested_val > 0 else 0.0
        
        # v32.7: Sovereign Guard Keys
        heatmap_series.append({
            'x': h.get('Ticker', 'N/A'),
            'y': truncate_decimal(val, 2),
            'val_pct': truncate_decimal(pct, 4),
            'company_name': h.get('Name', h.get('Ticker', 'N/A')),
            'shares_held': f"{truncate_decimal(safe_val(h.get('Shares')), 2):,.2f}",
            'formatted_value': f"£{val:,.2f}", # Pre-formatted
            'formatted_pl_gbp': f"{'+' if pnl >= 0 else ''}£{abs(pnl):,.2f}",
            'formatted_pl_pct': f"({pct*100:+.2f}%)",
            'price_avg': f"{h.get('Currency', '')} {truncate_decimal(safe_val(h.get('Avg_Price')), 2)}",
            'price_cur': f"{h.get('Currency', '')} {truncate_decimal(safe_val(h.get('Price')), 2)}",
            'currency': h.get('Currency', 'GBP'), 
            'pl_per_share_gbp': 0, # Legacy placeholder or calc if needed
            'pl_per_share_pct': 0
        })

    # 4. Fortress Table
    fortress_display = []
    for h in holdings:
        val = safe_val(h.get('Value_GBP', h.get('Value', 0))) # Support both keys
        pnl = safe_val(h.get('PL_GBP', h.get('PL', 0)))
        invested = val - pnl
        pct = (pnl / invested) * 100 if invested > 0 else 0.0
        
        tier = h.get('Tier', h.get('tier', '2'))
        target_weight = 0.08 if tier in ['1+', '1'] else 0.05
        current_weight = (val / total_wealth) if total_wealth > 0 else 0.0
        
        fortress_display.append({
            # New keys for my new section
            'ticker': h.get('Ticker', 'N/A'),
            'company': h.get('Name', h.get('Ticker', 'N/A')),
            'shares': truncate_decimal(safe_val(h.get('Shares')), 4),
            'avg_price': truncate_decimal(safe_val(h.get('Avg_Price')), 2),
            'current_price': truncate_decimal(safe_val(h.get('Price')), 2),
            'value_gbp': truncate_decimal(val, 2),
            'real_pl_gbp': truncate_decimal(pnl, 2),
            'real_pl_pct': truncate_decimal(pct, 2),
            'tier': tier,
            # Legacy keys for existing Fortress loop (line 694)
            'book_cost': truncate_decimal(val - pnl, 2),
            'weight_current': truncate_decimal(safe_val(h.get('Weight')) / 100.0, 4) if 'Weight' in h else truncate_decimal(current_weight, 4),
            'weight_target': truncate_decimal(target_weight, 4),
            'real_pl': truncate_decimal(pnl, 2),
            'fx_impact': truncate_decimal(safe_val(h.get('FX_Impact')), 2),
            'qell_rating': 'PASS', # Default or calc if needed
            'qell_score': 5,        # Default or calc if needed
            'action': 'HOLD'       # Default
        })
    
    # Sort by Real P/L (Best to Worst)
    fortress_display.sort(key=lambda x: x['real_pl_gbp'], reverse=True)

    # 5. Sniper List
    sniper_display = []
    for s in sniper_raw:
        dist = safe_val(s.get('distance_pct'))
        snippet = s.get('hypothesis', s.get('default_thesis', 'No intelligence available.'))
        src = s.get('source', 'System Default')
        
        # Calculate target params for template compatibility
        tier = s.get('tier', '2')
        t_weight = 0.08 if tier in ['1+', '1'] else 0.05
        t_gbp = total_wealth * t_weight
        l_price = safe_val(s.get('target_price'))
        
        sniper_display.append({
            'ticker': s.get('t212_ticker', s.get('ticker', 'N/A')),
            'name': s.get('name', 'N/A'),
            'tier': tier,
            'hypothesis': snippet,
            'source': src,
            'limit_price': l_price,
            'target_weight': t_weight,
            'target_gbp': t_gbp,
            'expected_growth': safe_val(s.get('expected_growth')),
            'shares': int(t_gbp / l_price) if l_price > 0 else 0,
            # Additional keys
            'current_price': truncate_decimal(safe_val(s.get('live_price')), 2),
            'distance_pct': truncate_decimal(dist, 2),
            'status': s.get('status', 'WATCH')
        })

    # 6. Final Template Context
    now = datetime.now()
    tax_end = datetime(now.year + (1 if now.month > 4 or (now.month == 4 and now.day > 5) else 0), 4, 5)
    days_to_tax = (tax_end - now).days

    # v31.6 Account History Loading
    history_log = []
    log_path = "data/history_log.json"
    if os.path.exists(log_path):
        try:
            with open(log_path, 'r') as f:
                history_log = json.load(f)
                history_log.sort(key=lambda x: x[0])
        except Exception as e:
            print(f"      [WARN] History log load failed: {e}")

    # v32.14 Sovereign Guard logic: Legend & Invested Funds Weight
    total_invested = total_wealth - cash_dry - blocked
    if total_invested <= 0:
        total_invested = sum(h.get('Value_GBP', 0) for h in holdings)
        
    # v32.13: Generate Oracle Ring with the correct denominator
    donut_chart_svg = generate_oracle_ring(holdings, total_invested)

    # v32.13: Compact Grid Legend (Tickers Only)
    # Using 'ticker-legend' class for updated CSS
    legend_html = '<div class="ticker-legend">'
    sorted_holdings = sorted(holdings, key=lambda x: x.get('Value_GBP', 0), reverse=True)
    
    colors = ["#4f46e5", "#10b981", "#ef4444", "#f59e0b", "#8b5cf6", "#ec4899", "#06b6d4", "#3b82f6", "#f43f5e", "#10b981"]
    
    for i, h in enumerate(sorted_holdings):
        val = h.get('Value_GBP', 0)
        weight = (val / total_invested * 100) if total_invested > 0 else 0
        
        # Show even small holdings in legend if they exist, but maybe limit count if massive
        if weight < 0.01: continue 
        
        ticker = h.get('Ticker', 'N/A')
        color = colors[i % len(colors)]
        safe_name = h.get('Name', ticker).replace("'", "\\'")
        pct_fmt = f"{weight:.1f}%"
        
        legend_html += f"""
        <div class="legend-ticker hover:bg-gray-50 transition-colors" 
             onclick="highlightSegment('{ticker}')"
             onmouseover="showTT('{safe_name}', '{pct_fmt}', '{color}')"
             onmouseout="hideTT()"
             style="border-left: 3px solid {color};">
            {ticker}
        </div>
        """
    legend_html += "</div>"

    context = {
        'version': "v0.15 Sovereign Finality",
        'last_update': datetime.now().strftime('%H:%M %d/%m'),
        "meta": {"timestamp": datetime.now().strftime("%Y-%m-%d %H:%M"), "version": "v0.15 Sovereign Finality"},
        'sync_time': datetime.now().strftime('%d/%m %H:%M'),
        'total_wealth_str': format_gbp_truncate(total_wealth),
        'total_return_str': f"{'+' if total_return >= 0 else ''}{format_gbp_truncate(total_return)}",
        'return_pct_str': f"{return_rate_pct:+.2f}%",
        'cash_dry_str': format_gbp_truncate(cash_dry),
        'available_dry_str': format_gbp_truncate(cash_dry),
        'pending_cash_str': format_gbp_truncate(blocked),
        'env': meta.get('env', 'LIVE'),
        'allocation_donut': donut_chart_svg,
        'legend_html': legend_html, # v32.13 Compact Legend
        'holdings': holdings,
        'fortress_holdings': fortress_display,
        'sniper_architect': sniper_display,
        'heatmap_dataset': json.dumps(heatmap_series),
        'account_history': json.dumps(history_log),
        'pending_orders': [],
        'portfolio_metrics': {
            'cash_balance': cash_dry,
            'total_wealth': total_wealth,
            'cash_hurdle': 0.038
        },
        'orb_intel': orb_intel,
        'solar': {
            'phase': 'STABLE',
            'tax': {
                'Limit Sentinel': 'Locked',
                'Days to April 5': str(days_to_tax),
                'Loss Harvesting': 'N/A (Tax Free)',
                'Bed & Breakfast': 'Clear'
            }
        }
    }

    # 7. Rendering Logic
    if not os.path.exists(TEMPLATE_FILE):
        print(f"[ARTIST] [ERROR] Template missing: {TEMPLATE_FILE}")
        return

    try:
        with open(TEMPLATE_FILE, 'r', encoding='utf-8') as f:
            template_code = f.read()
            
        template = Template(template_code)
        output_html = template.render(context)
        
        with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
            f.write(output_html)
            
        print(f"      [SUCCESS] Dashboard written to {OUTPUT_FILE} ({len(output_html)} bytes)")
        
    except Exception as e:
        print(f"      [ERROR] Rendering Failed: {e}")

if __name__ == "__main__":
    render()
